---
schemaVersion: "2.2"
description: "SSM Document for configuring an RDS gateway"
mainSteps:
  - name: ConfigureRDSGateway
    action: aws:runPowerShellScript
    precondition:
      StringEquals:
        - platformType
        - Windows
    inputs:
      runCommand:
        - |
          $ErrorActionPreference = "Stop" 
          $rdsGatewayHostname = "$env:computername"

          # Lookup domain configuration based on environment-name tag
          $token = Invoke-RestMethod -Headers @{"X-aws-ec2-metadata-token-ttl-seconds"=3600} -Method PUT -Uri http://169.254.169.254/latest/api/token
          $instanceId = Invoke-RestMethod -Headers @{"X-aws-ec2-metadata-token" = $token} -Method GET -Uri http://169.254.169.254/latest/meta-data/instance-id
          $tagsRaw = aws ec2 describe-tags --filters "Name=resource-id,Values=$instanceId"
          $tags = "$tagsRaw" | ConvertFrom-Json
          $environmentNameTag = ($tags.Tags | Where-Object  {$_.Key -eq "environment-name"}).Value
          $environment = $environmentNameTag.Split("-")[-1]
          $domainJoinUsername = "svc_join_domain"
          If ($environment -Eq "development" -Or $environment -Eq "test") {
              $secretAccountName = "hmpps-domain-services-test"
              $domainNameFQDN = "azure.noms.root"
              $domainNameNetbios = "AZURE"
          } ElseIf ($environment -Eq "preproduction" -Or $environment -Eq "production") {
              $secretAccountName = "hmpps-domain-services-production"
              $domainNameFQDN = "azure.hmpp.root"
              $domainNameNetbios = "HMPP"
          } Else {
              Write-Error "Unexpected environment_name tag $$environmentNameTag.tags.Value"
              Exit 1
          }

          # Lookup domain join secrets
          $accountIdsRaw = aws ssm get-parameter --name account_ids --with-decryption --query Parameter.Value --output text
          $accountIds = "$accountIdsRaw" | ConvertFrom-Json
          $secretAccountId = $accountIds.$secretAccountName
          $secretName = "/microsoft/AD/$domainNameFQDN/shared-passwords"
          $secretArn = "arn:aws:secretsmanager:eu-west-2:${secretAccountId}:secret:${secretName}"
          $accountId = aws sts get-caller-identity --query Account --output text
          $roleArn = "arn:aws:iam::${accountId}:role/EC2HmppsDomainSecretsRole"
          $session = "ssm-deploy-rds-gateway"
          $credsRaw = aws sts assume-role --role-arn "${roleArn}" --role-session-name "${session}"
          $creds = "$credsRaw" | ConvertFrom-Json
          $env:AWS_ACCESS_KEY_ID = $creds.Credentials.AccessKeyId
          $env:AWS_SECRET_ACCESS_KEY = $creds.Credentials.SecretAccessKey
          $env:AWS_SESSION_TOKEN = $creds.Credentials.SessionToken
          $secretValueRaw = aws secretsmanager get-secret-value --secret-id "${secretArn}" --query SecretString --output text
          $secretValue = "$secretValueRaw" | ConvertFrom-Json
          $env:AWS_ACCESS_KEY_ID = ""
          $env:AWS_SECRET_ACCESS_KEY = ""
          $env:AWS_SESSION_TOKEN = ""
          $domainJoinPassword = $secretValue.$domainJoinUsername
          $domainJoinPasswordSecureString = ConvertTo-SecureString $secretValue.$domainJoinUsername -AsPlainText -Force
         # $credentials = New-Object System.Management.Automation.PSCredential ("$domainNameNetbios\$domainJoinUsername", $domainJoinPasswordSecureString)


          #  $username = "$domainJoinUsername@AZURE.NOMS.ROOT"
          #  $password =  ConvertTo-SecureString "pass" -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($domainJoinUsername@$domainNameFQDN, $domainJoinPasswordSecureString)
          # TODO: Logic to handle different DCs


          Invoke-Command -ComputerName "$rdsGatewayHostname.$domainNameFQDN" -ArgumentList  $domainNameFQDN -credential $credential -scriptblock {
              # TODO: Logic to handle different user groups
              $domainNameFQDN = $args[0]
              $GroupName="Domain Users@$domainNameFQDN"
              $ManagedComputers="RDG_RDCBComputers"
              $CAPPath="RDS:\GatewayServer\CAP"
              $RAPPath="RDS:\GatewayServer\RAP"
              $MCGPath="RDS:\GatewayServer\GatewayManagedComputerGroups"
              $FilePath="C:\temp\export.cer"

              Import-Module RemoteDesktopServices
              Add-WindowsFeature -Name RDS-Gateway -IncludeManagementTools



              # Set Transport and SSL Bridging
              $config = Get-CimInstance -ClassName Win32_TSGatewayServerSettings -Namespace root\cimv2\terminalservices
              Invoke-CimMethod -MethodName EnableTransport -Arguments @{TransportType=[uint16]2;enable=$false} -InputObject $config
              Invoke-CimMethod -MethodName SetSslBridging -Arguments @{SslBridging=[uint32]1} -InputObject $config

              # Managed Computer Groups
              # TODO: What computers to manage?
              $MCGComputers=@($env:COMPUTERNAME)
              $MCGs=@(@{Name="RDG_RDCBComputers";Desc="All RDCB Computers in the deployment";Computers=$MCGComputers})

              # Connection Authorization Policies (CAP)
              $CAPs=@(@{Name="RDG_CAP_AllUsers";UserGroups=$GroupName;AuthMethod=1;Status=1})

              # Resource Authorization Policies (RAP
              $RAPs=@(@{Name="RDG_AllComputers";UserGroups=$GroupName;ComputerGroupType=2;ComputerGroup=$null})

              # Clean existing config
              $CAPs | ForEach-Object { if (Test-Path -Path "$CAPPath\$($_.Name)") { Remove-Item -Path "$CAPPath\$($_.Name)" -Recurse } }
              $RAPs | ForEach-Object { if (Test-Path -Path "$RAPPath\$($_.Name)") { Remove-Item -Path "$RAPPath\$($_.Name)" -Recurse } }
              $MCGs | ForEach-Object { if (Test-Path -Path "$MCGPath\$($_.Name)") { Remove-Item -Path "$MCGPath\$($_.Name)" -Recurse } }

              # Set CAPs / RAPs
              $MCGs | ForEach-Object { New-Item -Path $MCGPath -Name $_.Name -Description $_.Desc -Computers $_.Computers > $null }
              $CAPs | ForEach-Object { New-Item -Path $CAPPath -Name $_.Name -UserGroups $_.UserGroups -AuthMethod $_.AuthMethod -Status $_.Status > $null }
              $RAPs | ForEach-Object { New-Item -Path $RAPPath -Name $_.Name -UserGroups $_.UserGroups -ComputerGroupType $_.ComputerGroupType > $null }

              # Create self signed certificate for gateway
              $SelfSigned=New-SelfSignedCertificate -CertStoreLocation "Cert:\LocalMachine\My" -DnsName $env:COMPUTERNAME -FriendlyName $env:COMPUTERNAME -KeyAlgorithm "RSA" -HashAlgorithm "SHA256" -KeyDescription "RDG Key" -KeyLength 4096 -KeyUsage KeyEncipherment,DataEncipherment -KeyUsageProperty All
              $CertPassword=ConvertTo-SecureString -String "password" -Force â€“AsPlainText
              Export-PfxCertificate -Cert $SelfSigned.PSPath -FilePath $FilePath -Password $CertPassword > $null
              Import-PfxCertificate -CertStoreLocation "Cert:\LocalMachine\Root" -FilePath $FilePath -Password $CertPassword > $null
              Remove-Item -Path $FilePath

              $Certificate=$SelfSigned
              Set-Item -Path "RDS:\GatewayServer\SSLCertificate\Thumbprint" -Value $Certificate.Thumbprint
          }