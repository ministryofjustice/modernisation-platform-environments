---
schemaVersion: "2.2"
description: "SSM Document for configuring an RDS gateway"
mainSteps:
  - name: ConfigureRDSGateway
    action: aws:runPowerShellScript
    precondition:
      StringEquals:
        - platformType
        - Windows
    inputs:
      runCommand:
        - |
          $ErrorActionPreference = "Stop" 
          $GatewayHostname = "{{newHostname}}"

          # Lookup domain configuration based on environment-name tag
          $Token = Invoke-RestMethod -Headers @{"X-aws-ec2-metadata-token-ttl-seconds"=3600} -Method PUT -Uri http://169.254.169.254/latest/api/token
          $InstanceId = Invoke-RestMethod -Headers @{"X-aws-ec2-metadata-token" = $Token} -Method GET -Uri http://169.254.169.254/latest/meta-data/instance-id
          $TagsRaw = aws ec2 describe-tags --filters "Name=resource-id,Values=$InstanceId"
          $Tags = "$TagsRaw" | ConvertFrom-Json
          $EnvironmentNameTag = ($Tags.Tags | Where-Object  {$_.Key -eq "environment-name"}).Value
          $Environment = $EnvironmentNameTag.Split("-")[-1]
          $ServiceAccountUsername = "svc_configure_windows"
          If ($Environment -Eq "development" -Or $Environment -Eq "test") {
              $SecretAccountName = "hmpps-domain-services-test"
              $DomainNameFQDN = "azure.noms.root"
              $DomainNameNetbios = "AZURE"
          } ElseIf ($Environment -Eq "preproduction" -Or $Environment -Eq "production") {
              $SecretAccountName = "hmpps-domain-services-production"
              $DomainNameFQDN = "azure.hmpp.root"
              $DomainNameNetbios = "HMPP"
          } Else {
              Write-Error "Unexpected environment_name tag $$environmentNameTag.tags.Value"
              Exit 1
          }

          # Lookup service account secrets
          $AccountIdsRaw = aws ssm get-parameter --name account_ids --with-decryption --query Parameter.Value --output text
          $AccountIds = "$AccountIdsRaw" | ConvertFrom-Json
          $SecretAccountId = $AccountIds.$SecretAccountName
          $SecretName = "/microsoft/AD/$DomainNameFQDN/shared-passwords"
          $SecretArn = "arn:aws:secretsmanager:eu-west-2:${SecretAccountId}:secret:${SecretName}"
          $AccountId = aws sts get-caller-identity --query Account --output text
          $RoleArn = "arn:aws:iam::${AccountId}:role/EC2HmppsDomainSecretsRole"
          $Session = "ssm-deploy-rds-gateway"
          $CredsRaw = aws sts assume-role --role-arn "${RoleArn}" --role-session-name "${Session}"
          $Creds = "$CredsRaw" | ConvertFrom-Json
          $env:AWS_ACCESS_KEY_ID = $Creds.Credentials.AccessKeyId
          $env:AWS_SECRET_ACCESS_KEY = $Creds.Credentials.SecretAccessKey
          $env:AWS_SESSION_TOKEN = $Creds.Credentials.SessionToken
          $SecretValueRaw = aws secretsmanager get-secret-value --secret-id "${SecretArn}" --query SecretString --output text
          $SecretValue = "$SecretValueRaw" | ConvertFrom-Json
          $env:AWS_ACCESS_KEY_ID = ""
          $env:AWS_SECRET_ACCESS_KEY = ""
          $env:AWS_SESSION_TOKEN = ""
          $ServiceAccountPassword = $SecretValue.$ServiceAccountUsername
          $ServiceAccountPasswordSecureString = ConvertTo-SecureString $ServiceAccountPassword -AsPlainText -Force
          $Credentials = New-Object System.Management.Automation.PSCredential("$ServiceAccountUsername@$DomainNameFQDN", $ServiceAccountPasswordSecureString)
          $GatewayFQDN = "$GatewayHostname.$DomainNameFQDN"

          function Test-RemoteConnection {
            param([string]$computerName)
            $result = Test-NetConnection -ComputerName $computerName -Port 3389  # You can change the port as needed
            return $result.TcpTestSucceeded
          }

          # Check if gateway is ready after joining the domain
           while (-not (Test-RemoteConnection -computerName $GatewayFQDN)) {
            Write-Host "Waiting for $GatewayFQDN to be ready..."
            Start-Sleep -Seconds 10
          }

          Invoke-Command -ComputerName $GatewayFQDN -ArgumentList  $DomainNameFQDN  -credential $Credentials -scriptblock {
              $DomainNameFQDN = $args[0]
              $GroupName="Domain Users@$DomainNameFQDN"
              $ManagedComputers="RDG_RDCBComputers"
              $CAPPath="RDS:\GatewayServer\CAP"
              $RAPPath="RDS:\GatewayServer\RAP"
              $MCGPath="RDS:\GatewayServer\GatewayManagedComputerGroups"
              $FilePath="C:\temp\export.cer"

              Add-WindowsFeature -Name RDS-Gateway -IncludeAllSubFeature  -IncludeManagementTools
              Import-Module RemoteDesktopServices

              # Set Transport and SSL Bridging
              $config = Get-CimInstance -ClassName Win32_TSGatewayServerSettings -Namespace root\cimv2\terminalservices
              Invoke-CimMethod -MethodName EnableTransport -Arguments @{TransportType=[uint16]2;enable=$false} -InputObject $config
              Invoke-CimMethod -MethodName SetSslBridging -Arguments @{SslBridging=[uint32]1} -InputObject $config

              # Managed Computer Groups
              $MCGComputers=@($env:COMPUTERNAME)
              $MCGs=@(@{Name="RDG_RDCBComputers";Desc="All RDCB Computers in the deployment";Computers=$MCGComputers})

              # Connection Authorization Policies (CAP)
              $CAPs=@(@{Name="RDG_CAP_AllUsers";UserGroups=$GroupName;AuthMethod=1;Status=1})

              # Resource Authorization Policies (RAP
              $RAPs=@(@{Name="RDG_AllComputers";UserGroups=$GroupName;ComputerGroupType=2;ComputerGroup=$null})

              # Clean existing config
              $CAPs | ForEach-Object { if (Test-Path -Path "$CAPPath\$($_.Name)") { Remove-Item -Path "$CAPPath\$($_.Name)" -Recurse } }
              $RAPs | ForEach-Object { if (Test-Path -Path "$RAPPath\$($_.Name)") { Remove-Item -Path "$RAPPath\$($_.Name)" -Recurse } }
              $MCGs | ForEach-Object { if (Test-Path -Path "$MCGPath\$($_.Name)") { Remove-Item -Path "$MCGPath\$($_.Name)" -Recurse } }

              # Set CAPs / RAPs
              $MCGs | ForEach-Object { New-Item -Path $MCGPath -Name $_.Name -Description $_.Desc -Computers $_.Computers > $null }
              $CAPs | ForEach-Object { New-Item -Path $CAPPath -Name $_.Name -UserGroups $_.UserGroups -AuthMethod $_.AuthMethod -Status $_.Status > $null }
              $RAPs | ForEach-Object { New-Item -Path $RAPPath -Name $_.Name -UserGroups $_.UserGroups -ComputerGroupType $_.ComputerGroupType > $null }

              # Create self signed certificate for gateway
              $SelfSigned=New-SelfSignedCertificate -CertStoreLocation "Cert:\LocalMachine\My" -DnsName $env:COMPUTERNAME -FriendlyName $env:COMPUTERNAME -KeyAlgorithm "RSA" -HashAlgorithm "SHA256" -KeyDescription "RDG Key" -KeyLength 4096 -KeyUsage KeyEncipherment,DataEncipherment -KeyUsageProperty All
              $CertPassword=ConvertTo-SecureString -String "password" -Force â€“AsPlainText
              Export-PfxCertificate -Cert $SelfSigned.PSPath -FilePath $FilePath -Password $CertPassword > $null
              Import-PfxCertificate -CertStoreLocation "Cert:\LocalMachine\Root" -FilePath $FilePath -Password $CertPassword > $null
              Remove-Item -Path $FilePath

              $Certificate=$SelfSigned
              Set-Item -Path "RDS:\GatewayServer\SSLCertificate\Thumbprint" -Value $Certificate.Thumbprint
              Restart-Service -Name "TSGateway"
          }