# .github/workflows/ami_cleanup.yml
name: Cloud Cleanup (AMI & EBS)

on:
  # Push previews on your feature branch
  push:
    branches:
      - feature-11321-identifying-snapshots-to-be-deleted

  # Manual dispatch with <=10 inputs
  workflow_dispatch:
    inputs:
      application:
        description: 'Application folder name (e.g. cooker)'
        required: true
        type: string
        default: cooker
      environments:
        description: 'Comma-separated list of environments (e.g. development,production)'
        required: true
        type: string
        default: development
      cleanup_type:
        description: 'Which cleanup to run (ami, ebs, both)'
        required: true
        default: 'both'
        type: choice
        options: [ami, ebs, both]
      ami_cleanup_sh_args:
        description: 'Arguments passed to ami_cleanup.sh'
        required: false
        default: "-c -m 3"
        type: string
      ebs_age_in_months:
        description: 'Delete unattached EBS volumes older than this many months'
        required: false
        default: "1"
        type: string
      confirm_delete:
        description: 'true = perform deletion; false = preview only'
        required: true
        default: false
        type: boolean
      # CONSOLIDATED: one toggle + one minutes value for both AMI/EBS in preview
      test_mode:
        description: 'Enable 10-minute minute-based test window in PREVIEW'
        required: false
        default: false
        type: boolean
      age_minutes:
        description: 'Minutes threshold when test_mode is enabled'
        required: false
        default: "10"
        type: string
      # LIVE switch to also apply the 10-minute window
      live_test_mode:
        description: 'Apply the same 10-minute window in LIVE deletions (testing only!)'
        required: false
        default: false
        type: boolean

permissions:
  id-token: write
  contents: read

# Defaults (can be overridden by workflow_dispatch)
env:
  APPLICATION:      ${{ github.event.inputs.application || 'cooker' }}
  ENVIRONMENTS:     ${{ github.event.inputs.environments || 'development' }}
  AMI_ARGS:         ${{ github.event.inputs.ami_cleanup_sh_args || '-c -m 3' }}
  EBS_MONTHS:       ${{ github.event.inputs.ebs_age_in_months || '1' }}
  TEST_MODE:        ${{ github.event.inputs.test_mode || 'false' }}
  AGE_MINUTES:      ${{ github.event.inputs.age_minutes || '10' }}
  LIVE_TEST_MODE:   ${{ github.event.inputs.live_test_mode || 'false' }}

jobs:
  build-matrix:
    name: Build Account Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.strategy.outputs.matrix }}
    steps:
      - name: Build strategy matrix
        id: strategy
        run: |
          set -euo pipefail
          app="${APPLICATION}"
          envs_str="${ENVIRONMENTS}"
          IFS=', ' read -r -a envs <<< "$envs_str"
          echo '{"include":[' > matrix.json
          for env in "${envs[@]}"; do
            acc="${app}-${env}"
            echo "{\"account_name\":\"$acc\"}," >> matrix.json
          done
          sed -i '$ s/,$//' matrix.json
          echo ']}' >> matrix.json
          echo 'matrix<<EOF' >> $GITHUB_OUTPUT
          cat matrix.json >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT

  fetch-secrets:
    name: Fetch ENV management secrets
    uses: ministryofjustice/modernisation-platform-github-actions/.github/workflows/aws-secrets-management.yml@4eceb2a416a197e91dc557c2ef0b5dd9afe29e0c
    secrets:
      MODERNISATION_PLATFORM_ACCOUNT_NUMBER: ${{ secrets.MODERNISATION_PLATFORM_ACCOUNT_ID }}
      PASSPHRASE: ${{ secrets.PASSPHRASE }}

  # -------------------------
  # PREVIEW (Dry-Run)
  # -------------------------
  preview:
    name: Preview Deletions (Dry-Run)
    runs-on: ubuntu-latest
    needs: [build-matrix, fetch-secrets]
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && fromJSON(github.event.inputs.confirm_delete) == false) }}
    strategy:
      matrix: ${{ fromJson(needs.build-matrix.outputs.matrix) }}
      max-parallel: 1
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Ensure scripts are executable
        run: chmod +x scripts/*.sh

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Decrypt Secrets (ENVIRONMENT_MANAGEMENT)
        uses: ministryofjustice/modernisation-platform-github-actions/decrypt-secrets@4eceb2a416a197e91dc557c2ef0b5dd9afe29e0c
        with:
          environment_management: ${{ needs.fetch-secrets.outputs.environment_management }}
          github_ci_user_environments_repo_pat: ${{ needs.fetch-secrets.outputs.github_ci_user_environments_repo_pat }}
          PASSPHRASE: ${{ secrets.PASSPHRASE }}

      - name: Resolve AWS Account Number
        run: |
          set -euo pipefail
          ACCOUNT_NAME="${{ matrix.account_name }}"
          ACCOUNT_NUMBER=$(jq -r -e --arg account_name "${ACCOUNT_NAME}" '.account_ids[$account_name]' <<< "$ENVIRONMENT_MANAGEMENT")
          echo "::add-mask::$ACCOUNT_NUMBER"
          echo "ACCOUNT_NUMBER=${ACCOUNT_NUMBER}" >> $GITHUB_ENV

      - name: Configure AWS Credentials (github-actions role)
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: "arn:aws:iam::${{ env.ACCOUNT_NUMBER }}:role/github-actions"
          role-session-name: "cleanup-preview-${{ matrix.account_name }}"
          aws-region: eu-west-2

      - name: Assume downstream infra role (MemberInfrastructureAccess)
        run: |
          set -euo pipefail
          CREDS_JSON=$(aws sts assume-role --role-arn "arn:aws:iam::${ACCOUNT_NUMBER}:role/MemberInfrastructureAccess" --role-session-name "preview-${{ matrix.account_name }}" --output json)
          export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId'     <<< "$CREDS_JSON")
          export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' <<< "$CREDS_JSON")
          export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken'    <<< "$CREDS_JSON")
          echo "Assumed downstream role: MemberInfrastructureAccess"

      - name: Quick inventory (sanity)
        run: |
          set -euo pipefail
          echo "Matrix account name: ${{ matrix.account_name }}"
          echo "Resolved account number: ${ACCOUNT_NUMBER}"
          echo "Assumed downstream role: MemberInfrastructureAccess"
          echo "==== AWS STS Caller Identity ===="
          aws sts get-caller-identity
          echo "==== AWS Region (from config/env) ===="
          echo "aws configure get region => $(aws configure get region || true)"
          echo "AWS_REGION=$AWS_REGION AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION"
          echo "==== AMIs named 'cleanup-test*' (owners self) ===="
          aws ec2 describe-images --owners self \
            --filters Name=name,Values='cleanup-test*' \
            --query "Images[].{Id:ImageId,Name:Name,When:CreationDate}" \
            --output table || true
          echo "==== Unattached EBS volumes (available) â€” top 50 ===="
          aws ec2 describe-volumes \
            --filters Name=status,Values=available \
            --query "Volumes[0:50].[VolumeId,CreateTime,State,Tags[?Key=='Name']|[0].Value]" \
            --output table || true

      - name: Set 10-minute test flags (preview only)
        run: |
          echo "AMI_TEST_FLAGS=--test-mode --age-minutes ${AGE_MINUTES}" >> $GITHUB_ENV
          echo "EBS_TEST_FLAGS=--test-mode --age-minutes ${AGE_MINUTES}" >> $GITHUB_ENV
          echo "Preview will use minute-based window: ${AGE_MINUTES} minute(s)"

      - name: AMI Preview (dry-run)
        if: ${{ github.event_name == 'push' || github.event.inputs.cleanup_type == 'ami' || github.event.inputs.cleanup_type == 'both' }}
        id: ami_preview
        run: |
          set -euo pipefail
          app="${APPLICATION}"
          args="${AMI_ARGS}"
          region="eu-west-2"

          echo "[PREVIEW] Scanning AMIs in ${region} (dry-run; no deletion)"
          echo "AMI_ARGS: ${args}"
          echo "Effective AMI test flags: ${AMI_TEST_FLAGS:-<none>}"
          echo "----------------------------------------------------"

          # DRY RUN: generate command list & candidates
          scripts/ami_cleanup.sh -a "$app" -s ami_commands.sh ${AMI_TEST_FLAGS:-} $args -d delete || true

          # Capture AMI->snapshot map for visibility (no deletion in preview)
          > ami_snapshots.csv
          for AMI in $(grep -Eo 'ami-[0-9a-f]+' ami_commands.sh | sort -u); do
            SNAPS=$(aws ec2 describe-images --image-ids "$AMI" \
              --query "Images[0].BlockDeviceMappings[].Ebs.SnapshotId" --output text 2>/dev/null || true)
            for S in $SNAPS; do
              [[ "$S" == "None" || -z "$S" ]] && continue
              echo "${AMI},${S}" >> ami_snapshots.csv
            done
          done

          TOTAL="$(grep -c '^aws ec2 deregister-image' ami_commands.sh || true)"
          [[ -f ami_candidates.csv ]] || touch ami_candidates.csv

          if [[ -s ami_candidates.csv ]]; then
            echo "Top AMI candidates (ImageId,OwnerId,CreationDate,Public,Name):"
            head -n 20 ami_candidates.csv || true
          else
            echo "[PREVIEW] No AMIs found matching cleanup filters."
          fi

          echo "ami_count=${TOTAL}" >> "$GITHUB_OUTPUT"

      - name: Upload AMI Preview Artifacts
        if: ${{ always() && (github.event_name == 'push' || github.event.inputs.cleanup_type == 'ami' || github.event.inputs.cleanup_type == 'both') }}
        uses: actions/upload-artifact@v4
        with:
          name: ami-preview-${{ matrix.account_name }}
          path: |
            ami_candidates.csv
            ami_commands.sh
            ami_snapshots.csv
          if-no-files-found: warn

      - name: EBS Preview (dry-run)
        if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && (github.event.inputs.cleanup_type == 'ebs' || github.event.inputs.cleanup_type == 'both')) }}
        id: ebs_preview
        run: |
          set -euo pipefail
          months="${EBS_MONTHS}"
          echo "[PREVIEW] Listing unattached EBS volumes older than ${months} month(s) (dry-run only; no deletion)"
          echo "Effective EBS test flags: ${EBS_TEST_FLAGS:-<none>}"
          scripts/ebs_cleanup.sh ${EBS_TEST_FLAGS:-} -m "$months" unattached | tee ebs_candidates.txt || true
          EBS_COUNT="$( (grep -Eo 'vol-[0-9a-f]+' ebs_candidates.txt || true) | sort -u | wc -l | tr -d ' ' )"
          echo "Total unattached volumes matching filter: ${EBS_COUNT}"

          if [[ -s ebs_candidates.txt ]]; then
            echo "Top EBS candidates (volume IDs):"
            (grep -Eo 'vol-[0-9a-f]+' ebs_candidates.txt || true) | sort -u | head -n 20
          else
            echo "[PREVIEW] No unattached volumes found matching the filter."
          fi

          echo "ebs_count=${EBS_COUNT}" >> "$GITHUB_OUTPUT"
          [[ -f ebs_candidates.txt ]] || touch ebs_candidates.txt

      - name: Upload EBS Preview Artifacts
        if: ${{ always() && (github.event_name == 'push' || github.event.inputs.cleanup_type == 'ebs' || github.event.inputs.cleanup_type == 'both') }}
        uses: actions/upload-artifact@v4
        with:
          name: ebs-preview-${{ matrix.account_name }}
          path: ebs_candidates.txt
          if-no-files-found: warn

  # -------------------------
  # LIVE (Deletion)
  # -------------------------
  ami-delete:
    name: AMI Delete (Live)
    runs-on: ubuntu-latest
    needs: [build-matrix, fetch-secrets]
    if: >
      (github.event_name == 'push' && (
        contains(github.event.head_commit.message, '[CLEANUP LIVE AMI]') ||
        contains(github.event.head_commit.message, '[CLEANUP LIVE BOTH]')
      )) ||
      (github.event_name == 'workflow_dispatch' &&
        (github.event.inputs.cleanup_type == 'ami' || github.event.inputs.cleanup_type == 'both') &&
        fromJSON(github.event.inputs.confirm_delete) == true)
    environment: ${{ matrix.account_name }}
    strategy:
      matrix: ${{ fromJson(needs.build-matrix.outputs.matrix) }}
      max-parallel: 1
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Ensure scripts are executable
        run: chmod +x scripts/*.sh

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Decrypt Secrets (ENVIRONMENT_MANAGEMENT)
        uses: ministryofjustice/modernisation-platform-github-actions/decrypt-secrets@4eceb2a416a197e91dc557c2ef0b5dd9afe29e0c
        with:
          environment_management: ${{ needs.fetch-secrets.outputs.environment_management }}
          github_ci_user_environments_repo_pat: ${{ needs.fetch-secrets.outputs.github_ci_user_environments_repo_pat }}
          PASSPHRASE: ${{ secrets.PASSPHRASE }}

      - name: Resolve AWS Account Number
        run: |
          set -euo pipefail
          ACCOUNT_NAME="${{ matrix.account_name }}"
          ACCOUNT_NUMBER=$(jq -r -e --arg account_name "${ACCOUNT_NAME}" '.account_ids[$account_name]' <<< "$ENVIRONMENT_MANAGEMENT")
          echo "::add-mask::$ACCOUNT_NUMBER"
          echo "ACCOUNT_NUMBER=${ACCOUNT_NUMBER}" >> $GITHUB_ENV

      - name: Configure AWS Credentials (github-actions role)
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: "arn:aws:iam::${{ env.ACCOUNT_NUMBER }}:role/github-actions"
          role-session-name: "ami-delete-${{ matrix.account_name }}"
          aws-region: eu-west-2

      # 1) PLAN (dry run) to get candidate AMIs and capture snapshot mapping BEFORE deletion
      - name: Plan AMI deletion & capture snapshot mapping
        run: |
          set -euo pipefail
          # Assume MemberInfrastructureAccess in this same shell (org pattern)
          CREDS_JSON=$(aws sts assume-role --role-arn "arn:aws:iam::${ACCOUNT_NUMBER}:role/MemberInfrastructureAccess" --role-session-name "live-ami-plan-${{ matrix.account_name }}" --output json)
          export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId'     <<< "$CREDS_JSON")
          export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' <<< "$CREDS_JSON")
          export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken'    <<< "$CREDS_JSON")

          echo "==== AWS STS Caller Identity (LIVE AMI PLAN) ===="
          aws sts get-caller-identity

          app="${APPLICATION}"
          args="${AMI_ARGS}"

          # Dry-run to generate ami_commands.sh without deleting
          scripts/ami_cleanup.sh -a "$app" -s ami_commands.sh ${AMI_TEST_FLAGS:-} $args -d delete || true

          # Build CSV: ami_id,snapshot_id for all candidates
          > ami_snapshots.csv
          AMI_IDS=$(grep -Eo 'ami-[0-9a-f]+' ami_commands.sh | sort -u || true)
          if [[ -n "$AMI_IDS" ]]; then
            for AMI in $AMI_IDS; do
              SNAPS=$(aws ec2 describe-images --image-ids "$AMI" \
                --query "Images[0].BlockDeviceMappings[].Ebs.SnapshotId" --output text 2>/dev/null || true)
              for S in $SNAPS; do
                [[ "$S" == "None" || -z "$S" ]] && continue
                echo "${AMI},${S}" >> ami_snapshots.csv
              done
            done
          fi
          [[ -f ami_candidates.csv ]] || touch ami_candidates.csv

      # 2) DELETE AMIs
      - name: Recompute & Delete AMIs (Live)
        run: |
          set -euo pipefail
          # Assume MemberInfrastructureAccess in this same shell (org pattern)
          CREDS_JSON=$(aws sts assume-role --role-arn "arn:aws:iam::${ACCOUNT_NUMBER}:role/MemberInfrastructureAccess" --role-session-name "live-ami-delete-${{ matrix.account_name }}" --output json)
          export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId'     <<< "$CREDS_JSON")
          export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' <<< "$CREDS_JSON")
          export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken'    <<< "$CREDS_JSON")

          echo "==== AWS STS Caller Identity (LIVE AMI DELETE) ===="
          aws sts get-caller-identity

          app="${APPLICATION}"
          args="${AMI_ARGS}"
          echo "[LIVE] Collecting candidates and deregistering (if any)"
          echo "Effective AMI test flags: ${AMI_TEST_FLAGS:-<none>}"

          # Generate candidate deregistration commands (same flags as preview)
          scripts/ami_cleanup.sh -a "$app" -s ami_commands.sh ${AMI_TEST_FLAGS:-} $args -d delete || true

          # Execute generated commands if any
          if [[ -s ami_commands.sh ]]; then
            echo "Executing generated AMI deregistration commands..."
            bash ami_commands.sh || true
          fi

          TOTAL="$(grep -c '^aws ec2 deregister-image' ami_commands.sh || true)"
          echo "Total deregister-image commands generated (and executed): ${TOTAL}"
          if [[ -s ami_commands.sh ]]; then
            echo "First 20 deregistration commands:"
            grep '^aws ec2 deregister-image' ami_commands.sh | head -n 20 || true
          else
            echo "[LIVE] No AMIs found matching the deletion criteria."
          fi
          [[ -f ami_candidates.csv ]] || touch ami_candidates.csv
          [[ -f ami_commands.sh ]] || touch ami_commands.sh

      # 3) Fallback: delete orphaned snapshots for those deregistered AMIs (with retention guards + retries)
      - name: Delete orphaned snapshots (fallback)
        if: always()
        run: |
          set -euo pipefail
          # Assume MemberInfrastructureAccess in this same shell (org pattern)
          CREDS_JSON=$(aws sts assume-role --role-arn "arn:aws:iam::${ACCOUNT_NUMBER}:role/MemberInfrastructureAccess" --role-session-name "live-ami-snaps-${{ matrix.account_name }}" --output json)
          export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId'     <<< "$CREDS_JSON")
          export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' <<< "$CREDS_JSON")
          export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken'    <<< "$CREDS_JSON")

          echo "==== AWS STS Caller Identity (LIVE SNAPSHOT CLEANUP) ===="
          aws sts get-caller-identity

          aws_try() {
            # aws_try <command...>
            # Simple exponential backoff (max 5 attempts)
            local max=5 delay=2 attempt=1
            while true; do
              "$@" && return 0
              code=$?
              if (( attempt >= max )); then
                echo "Command failed after ${attempt} attempts: $*" >&2
                return $code
              fi
              sleep $delay
              delay=$((delay*2))
              attempt=$((attempt+1))
            done
          }

          if [[ ! -s ami_snapshots.csv ]]; then
            echo "No snapshot map captured; skipping."
            exit 0
          fi

          echo "[LIVE] Deleting snapshots referenced by deregistered AMIs (skipping retained/backups)..."
          deleted=0
          while IFS=',' read -r AMI_ID SNAP_ID; do
            [[ -z "$SNAP_ID" ]] && continue
            [[ "$SNAP_ID" =~ ^snap- ]] || continue

            # Fetch minimal details to decide retention
            read -r TAGS DESC NAME <<< "$(aws ec2 describe-snapshots \
              --snapshot-ids "$SNAP_ID" \
              --query '[Snapshots[0].Tags, Snapshots[0].Description, Snapshots[0].Tags[?Key==`Name`]|[0].Value]' \
              --output text 2>/dev/null || true)"

            # Skip if tags indicate retention (Retain/Backup=true/yes/1)
            if grep -Eiq '(^|[[:space:]])(Retain|Backup)[[:space:]]*=[[:space:]]*(true|yes|1)' <<< "${TAGS:-}"; then
              echo "Skip $SNAP_ID (retention tag)."
              continue
            fi

            # Skip if name/description suggests AwsBackup
            if grep -qi 'AwsBackup' <<< "${DESC:-} ${NAME:-}"; then
              echo "Skip $SNAP_ID (AwsBackup)."
              continue
            fi

            echo "Deleting snapshot $SNAP_ID (from $AMI_ID)"
            aws_try aws ec2 delete-snapshot --snapshot-id "$SNAP_ID" || true
            deleted=$((deleted+1))
          done < ami_snapshots.csv

          echo "Total snapshots delete attempts: $deleted"

      - name: Upload AMI Live Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ami-live-${{ matrix.account_name }}
          path: |
            ami_candidates.csv
            ami_commands.sh
            ami_snapshots.csv
          if-no-files-found: warn

  ebs-delete:
    name: EBS Delete (Live)
    runs-on: ubuntu-latest
    needs: [build-matrix, fetch-secrets]
    if: >
      (github.event_name == 'push' && (
        contains(github.event.head_commit.message, '[CLEANUP LIVE EBS]') ||
        contains(github.event.head_commit.message, '[CLEANUP LIVE BOTH]')
      )) ||
      (github.event_name == 'workflow_dispatch' &&
        (github.event.inputs.cleanup_type == 'ebs' || github.event.inputs.cleanup_type == 'both') &&
        fromJSON(github.event.inputs.confirm_delete) == true)
    environment: ${{ matrix.account_name }}
    strategy:
      matrix: ${{ fromJson(needs.build-matrix.outputs.matrix) }}
      max-parallel: 1
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Ensure scripts are executable
        run: chmod +x scripts/*.sh

      - name: Ensure jq is available
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

      - name: Decrypt Secrets (ENVIRONMENT_MANAGEMENT)
        uses: ministryofjustice/modernisation-platform-github-actions/decrypt-secrets@4eceb2a416a197e91dc557c2ef0b5dd9afe29e0c
        with:
          environment_management: ${{ needs.fetch-secrets.outputs.environment_management }}
          github_ci_user_environments_repo_pat: ${{ needs.fetch-secrets.outputs.github_ci_user_environments_repo_pat }}
          PASSPHRASE: ${{ secrets.PASSPHRASE }}

      - name: Resolve AWS Account Number
        run: |
          set -euo pipefail
          ACCOUNT_NAME="${{ matrix.account_name }}"
          ACCOUNT_NUMBER=$(jq -r -e --arg account_name "${ACCOUNT_NAME}" '.account_ids[$account_name]' <<< "$ENVIRONMENT_MANAGEMENT")
          echo "::add-mask::$ACCOUNT_NUMBER"
          echo "ACCOUNT_NUMBER=${ACCOUNT_NUMBER}" >> $GITHUB_ENV

      - name: Configure AWS Credentials (github-actions role)
        uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502
        with:
          role-to-assume: "arn:aws:iam::${{ env.ACCOUNT_NUMBER }}:role/github-actions"
          role-session-name: "ebs-delete-${{ matrix.account_name }}"
          aws-region: eu-west-2

      - name: Delete EBS Volumes (Live)
        run: |
          set -euo pipefail
          # Assume MemberInfrastructureAccess in this same shell (org pattern)
          CREDS_JSON=$(aws sts assume-role --role-arn "arn:aws:iam::${ACCOUNT_NUMBER}:role/MemberInfrastructureAccess" --role-session-name "live-ebs-${{ matrix.account_name }}" --output json)
          export AWS_ACCESS_KEY_ID=$(jq -r '.Credentials.AccessKeyId'     <<< "$CREDS_JSON")
          export AWS_SECRET_ACCESS_KEY=$(jq -r '.Credentials.SecretAccessKey' <<< "$CREDS_JSON")
          export AWS_SESSION_TOKEN=$(jq -r '.Credentials.SessionToken'    <<< "$CREDS_JSON")

          echo "==== AWS STS Caller Identity (LIVE EBS DELETE) ===="
          aws sts get-caller-identity

          months="${EBS_MONTHS}"
          echo "[LIVE] Deleting unattached EBS volumes older than ${months} month(s)"
          echo "Effective EBS test flags: ${EBS_TEST_FLAGS:-<none>}"
          scripts/ebs_cleanup.sh ${EBS_TEST_FLAGS:-} -m "$months" delete | tee ebs_delete_log.txt || true
          DELETED_COUNT="$( (grep -Eo 'vol-[0-9a-f]+' ebs_delete_log.txt || true) | sort -u | wc -l | tr -d ' ' )"
          echo "Total volumes processed for deletion: ${DELETED_COUNT}"
          if [[ -s ebs_delete_log.txt && "${DELETED_COUNT}" -gt 0 ]]; then
            echo "First 20 volume IDs processed:"
            (grep -Eo 'vol-[0-9a-f]+' ebs_delete_log.txt || true) | sort -u | head -n 20
          else
            echo "[LIVE] No EBS volumes matched the deletion criteria."
          fi
          [[ -f ebs_delete_log.txt ]] || touch ebs_delete_log.txt

      - name: Upload EBS Live Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ebs-live-${{ matrix.account_name }}
          path: ebs_delete_log.txt
          if-no-files-found: warn
